<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Terraria-like Map Generator</title>
    <link rel="stylesheet" href="./mapgen.css">
</head>
<body>
    <h1>Terraria-like Map Generator</h1>

    <div class="container">
        <canvas id="canvas" width="1920" height="1920"></canvas>

        <div class="controls">
            <h2>General Settings</h2>
            <div class="control-group">
                <label for="width">Width:</label>
                <input type="number" id="width" value="1920">
            </div>
            <div class="control-group">
                <label for="height">Height:</label>
                <input type="number" id="height" value="1920">
            </div>
            <div class="control-group">
                <label for="baseHeightFactor">Base Ground Height Factor:</label>
                <input type="range" id="baseHeightFactor" value="0.7" min="0.1" max="0.9" step="0.05">
            </div>
            <div class="control-group">
                <label for="smoothPasses">Smooth Passes:</label>
                <input type="number" id="smoothPasses" value="5" min="0" max="20">
            </div>

            <h2>Heightmap Waves</h2>
            <div class="control-group">
                <label for="sin1Amp">Sin1 Amplitude:</label>
                <input type="range" id="sin1Amp" value="20" min="0" max="100" step="1">
            </div>
            <div class="control-group">
                <label for="sin1Freq">Sin1 Frequency:</label>
                <input type="range" id="sin1Freq" value="0.01" min="0" max="0.1" step="0.001">
            </div>
            <div class="control-group">
                <label for="sin2Amp">Sin2 Amplitude:</label>
                <input type="range" id="sin2Amp" value="10" min="0" max="50" step="1">
            </div>
            <div class="control-group">
                <label for="sin2Freq">Sin2 Frequency:</label>
                <input type="range" id="sin2Freq" value="0.02" min="0" max="0.1" step="0.001">
            </div>
            <div class="control-group">
                <label for="sin3Amp">Sin3 Amplitude:</label>
                <input type="range" id="sin3Amp" value="5" min="0" max="25" step="1">
            </div>
            <div class="control-group">
                <label for="sin3Freq">Sin3 Frequency:</label>
                <input type="range" id="sin3Freq" value="0.05" min="0" max="0.2" step="0.001">
            </div>
            <div class="control-group">
                <label for="sin4Amp">Sin4 Amplitude:</label>
                <input type="range" id="sin4Amp" value="2" min="0" max="10" step="1">
            </div>
            <div class="control-group">
                <label for="sin4Freq">Sin4 Frequency:</label>
                <input type="range" id="sin4Freq" value="0.1" min="0" max="0.5" step="0.001">
            </div>
            <div class="control-group">
                <label for="randomAmp">Random Amplitude:</label>
                <input type="range" id="randomAmp" value="5" min="0" max="20" step="1">
            </div>

            <h2>Terrain Layers</h2>
            <div class="control-group">
                <label for="grassThickness">Grass Thickness:</label>
                <input type="range" id="grassThickness" value="3" min="1" max="10">
            </div>
            <div class="control-group">
                <label for="dirtLayerDepth">Dirt Layer Depth:</label>
                <input type="range" id="dirtLayerDepth" value="30" min="10" max="100">
            </div>

            <h2>Cave Generation</h2>
            <div class="control-group">
                <label for="caveDensity">Cave Density (more = more caves):</label>
                <input type="range" id="caveDensity" value="35" min="1" max="100">
            </div>
            <div class="control-group">
                <label for="caveSize">Cave Size (higher = larger blobs):</label>
                <input type="range" id="caveSize" value="70" min="10" max="200">
            </div>
            <div class="control-group">
                <label for="caveVerticalBias">Cave Vertical Bias:</label>
                <input type="range" id="caveVerticalBias" value="0.3" min="0" max="1" step="0.01">
            </div>
            <div class="control-group">
                <label for="caveVerticalFreq">Cave Vertical Freq:</label>
                <input type="range" id="caveVerticalFreq" value="0.05" min="0.001" max="0.1" step="0.001">
            </div>

            <h2>Water</h2>
            <div class="control-group">
                <label for="waterLevel">Water Level Factor:</label>
                <input type="range" id="waterLevel" value="0.35" min="0" max="1" step="0.01">
            </div>
            <div class="control-group">
                <label for="seedInput">Seed:</label>
                <input type="text" id="seedInput" value="12345">
            </div>
            <div class="control-group">
                <button id="randomSeedBtn">Get Seed</button>
            </div>
            <div class="control-group">
                <label>Current Seed:</label>
                <span id="seedDisplay">12345</span>
            </div>

            <div class="control-group">
                <button id="genBtn">Generate Map</button>
            </div>
            <div class="control-group">
                <button id="downloadBtn">Download Map</button>
            </div>
            <div class="control-group">
                <button id="loadSeedBtn">Load from Seed</button>
            </div>
        </div>
    </div>

    <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const widthInput = document.getElementById('width');
    const heightInput = document.getElementById('height');
    const caveDensityInput = document.getElementById('caveDensity');
    const caveSizeInput = document.getElementById('caveSize');
    const sin1Amp = document.getElementById('sin1Amp');
    const sin1Freq = document.getElementById('sin1Freq');
    const sin2Amp = document.getElementById('sin2Amp');
    const sin2Freq = document.getElementById('sin2Freq');
    const sin3Amp = document.getElementById('sin3Amp');
    const sin3Freq = document.getElementById('sin3Freq');
    const sin4Amp = document.getElementById('sin4Amp');
    const sin4Freq = document.getElementById('sin4Freq');
    const randomAmp = document.getElementById('randomAmp');
    const smoothPassesInput = document.getElementById('smoothPasses');
    const baseHeightFactor = document.getElementById('baseHeightFactor');
    const waterLevelInput = document.getElementById('waterLevel');
    const seedInput = document.getElementById('seedInput');
    const seedDisplay = document.getElementById('seedDisplay');
    const genBtn = document.getElementById('genBtn');
    const downloadBtn = document.getElementById('downloadBtn');
    const grassThicknessInput = document.getElementById('grassThickness');
    const dirtLayerDepthInput = document = document.getElementById('dirtLayerDepth');
    const caveVerticalBiasInput = document.getElementById('caveVerticalBias');
    const caveVerticalFreqInput = document.getElementById('caveVerticalFreq');
    const randomSeedBtn = document.getElementById('randomSeedBtn'); // Now "Get Seed"
    const loadSeedBtn = document.getElementById('loadSeedBtn'); // Now "Load from Seed"

    // --- Seeded Perlin Noise Implementation ---
    class SeededPerlin2D {
        constructor(seed) {
            this.P = new Array(512);
            this.permutation = this.generatePermutation(seed);
            for (let i = 0; i < 256; i++) {
                this.P[i] = this.permutation[i];
                this.P[i + 256] = this.permutation[i];
            }
        }

        generatePermutation(seed) {
            const rng = new LCG(seed); // Use LCG to generate a reproducible permutation table
            const p = Array.from({ length: 256 }, (_, i) => i);

            // Fisher-Yates shuffle
            for (let i = p.length - 1; i > 0; i--) {
                const j = Math.floor(rng.next() * (i + 1));
                [p[i], p[j]] = [p[j], p[i]];
            }
            return p;
        }

        fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
        lerp(a, b, t) { return a + t * (b - a); }
        grad(hash, x, y) {
            const h = hash & 15;
            const u = h < 8 ? x : y;
            const v = h < 4 ? y : h === 12 || h === 14 ? x : 0;
            return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
        }

        noise(x, y) {
            let X = Math.floor(x) & 255;
            let Y = Math.floor(y) & 255;

            x -= Math.floor(x);
            y -= Math.floor(y);

            let u = this.fade(x);
            let v = this.fade(y);

            let A = this.P[X] + Y;
            let B = this.P[X + 1] + Y;

            let AA = this.P[A];
            let AB = this.P[A + 1];
            let BA = this.P[B];
            let BB = this.P[B + 1];

            let val = this.lerp(
                this.lerp(this.grad(this.P[AA], x, y), this.grad(this.P[BA], x - 1, y), u),
                this.lerp(this.grad(this.P[AB], x, y - 1), this.grad(this.P[BB], x - 1, y - 1), u),
                v
            );
            return (val + 1) / 2; // Normalize output to [0, 1]
        }
    }
    // --- End Seeded Perlin Noise Implementation ---

    // Simple Seeded Random Number Generator (LCG)
    function LCG(seed) {
        this.m = Math.pow(2, 31) - 1; // Modulus
        this.a = 16807; // Multiplier
        this.c = 0; // Increment
        this.seed = (seed % this.m + this.m) % this.m; // Ensure seed is positive and within range
        if (this.seed === 0) this.seed = 1; // Avoid a seed of 0

        this.next = function() {
            this.seed = (this.a * this.seed + this.c) % this.m;
            return this.seed / this.m;
        };
    }

    let currentPerlinNoise; // Declare global Perlin noise instance
    let currentRNG; // Declare global LCG instance

    function generateMap() {
        // Use the seed from the input field, or a default if invalid
        const seed = parseInt(seedInput.value) || 12345;
        seedInput.value = seed; // Ensure the input field reflects the seed used
        seedDisplay.textContent = seed;

        currentRNG = new LCG(seed); // Initialize main LCG with the chosen seed
        currentPerlinNoise = new SeededPerlin2D(seed); // Initialize Perlin noise with the chosen seed

        const w = parseInt(widthInput.value) || 512;
        const h = parseInt(heightInput.value) || 512;
        const baseHeightFactorValue = parseFloat(baseHeightFactor.value) || 0.7;
        const grassThickness = parseInt(grassThicknessInput.value) || 3;
        const dirtLayerDepth = parseInt(dirtLayerDepthInput.value) || 30;
        const caveDensity = parseInt(caveDensityInput.value) || 35;
        const caveSize = parseInt(caveSizeInput.value) || 70;
        const caveVerticalBias = parseFloat(caveVerticalBiasInput.value) || 0.3;
        const caveVerticalFreq = parseFloat(caveVerticalFreqInput.value) || 0.05;

        canvas.width = w;
        canvas.height = h;

        // --- Generate heightmap ---
        const heights = new Array(w);
        const baseHeight = h * baseHeightFactorValue; // Base ground level (from bottom)
        for (let x = 0; x < w; x++) {
            heights[x] =
                baseHeight +
                Math.sin(x * parseFloat(sin1Freq.value)) * parseFloat(sin1Amp.value) +
                Math.sin(x * parseFloat(sin2Freq.value)) * parseFloat(sin2Amp.value) +
                Math.sin(x * parseFloat(sin3Freq.value)) * parseFloat(sin3Amp.value) +
                Math.sin(x * parseFloat(sin4Freq.value)) * parseFloat(sin4Amp.value) +
                (currentRNG.next() - 0.5) * 2 * parseFloat(randomAmp.value); // Use the seeded RNG
        }

        // --- Smooth the heightmap ---
        const smoothPasses = parseInt(smoothPassesInput.value);
        for (let smoothPass = 0; smoothPass < smoothPasses; smoothPass++) {
            for (let i = 1; i < w - 1; i++) {
                    heights[i] = (heights[i - 1] + heights[i] + heights[i + 1]) / 3;
                }
            }

        // --- Generate terrain (solid ground first) ---
        const mapCells = Array(h)
            .fill(0) // 0 = Air
            .map(() => Array(w).fill(0));

        for (let x = 0; x < w; x++) {
            const groundY = Math.floor(h - heights[x]);
            for (let y = 0; y < h; y++) {
                if (y > groundY) {
                    mapCells[y][x] = 1; // 1 = Solid ground
                }
            }
        }

        // --- Generate Caves using Seeded Perlin Noise ---
        // Derive specific seeds for different noise patterns for reproducibility
        const caveNoiseSeedX = currentRNG.next() * 10000;
        const caveNoiseSeedY = currentRNG.next() * 10000;
        const caveScaleFactor = 0.01 * (200 / caveSize); // Inverse relationship: higher caveSize = smaller scale factor for noise
        const caveNoiseThreshold = caveDensity / 100; // Example: density 35 -> threshold 0.35 (noise < 0.35 is cave)

        for (let y = 0; y < h; y++) {
            for (let x = 0; x < w; x++) {
                const groundYForColumn = Math.floor(h - heights[x]);
                // Only carve if it's currently solid ground AND deep enough
                if (mapCells[y][x] === 1 && y > groundYForColumn + grassThickness + dirtLayerDepth) {
                    const noiseVal = currentPerlinNoise.noise(x * caveScaleFactor + caveNoiseSeedX, y * caveScaleFactor + caveNoiseSeedY);

                    // Apply vertical bias to the cave threshold
                    const currentVerticalBias = Math.sin(y * caveVerticalFreq) * caveVerticalBias * 0.5 + (caveVerticalBias * 0.5); // Normalize bias to be always positive
                    const finalCaveThreshold = caveNoiseThreshold - currentVerticalBias;

                    if (noiseVal < finalCaveThreshold) {
                        mapCells[y][x] = 0; // Carve out the cave (make it air)
                    }
                }
            }
        }

        // --- Apply Water (Modified) ---
        const globalWaterLevelY = h * parseFloat(waterLevelInput.value);

        // Derive specific seeds for different water patterns
        const caveWaterNoiseSeedX = currentRNG.next() * 10000;
        const caveWaterNoiseSeedY = currentRNG.next() * 10000;
        const caveWaterScale = 0.02; // How spread out cave water blobs are
        const caveWaterThreshold = 0.4; // Lower value = more cave water
        const minCaveWaterDepth = h * 0.6; // Don't spawn cave water too high up

        const puddleNoiseSeedX = currentRNG.next() * 10000;
        const puddleNoiseSeedY = currentRNG.next() * 10000;
        const puddleScale = 0.05; // How spread out surface puddles are
        const puddleThreshold = 0.3; // Lower value = more puddles
        const maxPuddleDepthBelowSurface = 5; // Puddles only appear just below the surface

        // First, fill in "global" water up to the waterLevel (for oceans/lakes)
        for (let y = 0; y < h; y++) {
            for (let x = 0; x < w; x++) {
                if (mapCells[y][x] === 0 && y > globalWaterLevelY) {
                        mapCells[y][x] = 2; // Mark as water
                }
            }
        }

        // Now, apply cave water and surface puddles
        for (let y = 0; y < h; y++) {
            for (let x = 0; x < w; x++) {
                const groundYForColumn = Math.floor(h - heights[x]);

                // --- Cave Water ---
                // If it's currently air, below the ground, and deep enough
                if (mapCells[y][x] === 0 && y > groundYForColumn && y > minCaveWaterDepth) {
                    const caveWaterNoise = currentPerlinNoise.noise(x * caveWaterScale + caveWaterNoiseSeedX, y * caveWaterScale + caveWaterNoiseSeedY);
                    if (caveWaterNoise < caveWaterThreshold) {
                        mapCells[y][x] = 2; // Mark as water
                    }
                }

                // --- Surface Puddles ---
                // If it's currently air, and just below or at the surface, and passes puddle noise
                // Check if it's within a small vertical range of the ground surface
                if (mapCells[y][x] === 0 && y >= groundYForColumn - maxPuddleDepthBelowSurface && y <= groundYForColumn + maxPuddleDepthBelowSurface) {
                    const puddleNoise = currentPerlinNoise.noise(x * puddleScale + puddleNoiseSeedX, y * puddleScale + puddleNoiseSeedY);
                    if (puddleNoise < puddleThreshold) {
                        mapCells[y][x] = 2; // Mark as water
                    }
                }
            }
        }

        // --- Create image based on mapCells ---
        const imageData = ctx.createImageData(w, h);
        const data = imageData.data;

        const mixNoiseScale = 0.03; // How fine-grained the mixing pattern is
        const mixNoiseSeedX = currentRNG.next() * 10000;
        const mixNoiseSeedY = currentRNG.next() * 10000;

        for (let y = 0; y < h; y++) {
            for (let x = 0; x < w; x++) {
                const index = (y * w + x) * 4;
                let r = 255, g = 255, b = 255; // default = air (white)

                const cellType = mapCells[y][x];
                const groundYForColumn = Math.floor(h - heights[x]); // The actual surface level for this x-coordinate

                if (cellType === 1) { // Solid Ground (Grass, Dirt, Stone)
                    if (y >= groundYForColumn && y < groundYForColumn + grassThickness) {
                        // Grass layer
                        r = 34; g = 139; b = 34; // Grass (Dark green)
                    } else if (y >= groundYForColumn + grassThickness && y < groundYForColumn + grassThickness + dirtLayerDepth) {
                        // Dirt layer
                        r = 139; g = 69; b = 19; // Dirt (Brown)
                    } else {
                        // Stone layer (deeper than dirt)
                        const noiseValue = currentPerlinNoise.noise(x * mixNoiseScale + mixNoiseSeedX, y * mixNoiseScale + mixNoiseSeedY);
                        const stoneColor = 100 + Math.floor(noiseValue * 50); // Stone (Dark grey, with subtle variation)
                        r = stoneColor; g = stoneColor; b = stoneColor;
                    }
                } else if (cellType === 2) { // Water
                    r = 30; g = 144; b = 255; // Dodger Blue
                } else {
                    // Air/Sky (cellType === 0)
                    // Gradient sky
                    const skyBlue = 150 + Math.floor((h - y) / h * 105);
                    r = Math.min(255, 200 + Math.floor(y / h * 55)); // Faint reddish tint near horizon
                    g = Math.min(255, skyBlue);
                    b = Math.min(255, skyBlue + 50);
                }

                data[index] = r;
                data[index + 1] = g;
                data[index + 2] = b;
                data[index + 3] = 255;
            }
        }

        ctx.putImageData(imageData, 0, 0);
    }

    function downloadImage() {
        canvas.toBlob(function (blob) {
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = 'terraria_map.png';
            document.body.appendChild(a);
            a.click();
            a.remove();
            URL.revokeObjectURL(a.href);
        }, 'image/png');
    }

    // A simple, reasonably good string hash function
    // From https://github.com/bryc/code/blob/master/jshash/PRNGs.md#cyrb53
    function cyrb53(str, seed = 0) {
        let h1 = 0xdeadbeef ^ seed, h2 = 0x41c6ce57 ^ seed;
        for (let i = 0, ch; i < str.length; i++) {
            ch = str.charCodeAt(i);
            h1 = Math.imul(h1 ^ ch, 2654435761);
            h2 = Math.imul(h2 ^ ch, 1597334677);
        }
        h1 = Math.imul(h1 ^ (h1>>>16), 2246822507);
        h1 ^= Math.imul(h2 ^ (h2>>>13), 3266489909);
        h2 = Math.imul(h2 ^ (h2>>>16), 2246822507);
        h2 ^= Math.imul(h1 ^ (h1>>>13), 3266489909);
      
        return 4294967296 * (2097151 & h2) + (h1>>>0);
    }


    // Function to collect current slider values and generate a seed
    function generateSeedFromSettings() {
        // Collect all relevant slider/input values
        const settings = [
            widthInput.value,
            heightInput.value,
            parseFloat(baseHeightFactor.value).toFixed(2), // Use toFixed for consistent string representation of floats
            parseInt(smoothPassesInput.value),
            parseInt(sin1Amp.value),
            parseFloat(sin1Freq.value).toFixed(3),
            parseInt(sin2Amp.value),
            parseFloat(sin2Freq.value).toFixed(3),
            parseInt(sin3Amp.value),
            parseFloat(sin3Freq.value).toFixed(3),
            parseInt(sin4Amp.value),
            parseFloat(sin4Freq.value).toFixed(3),
            parseInt(randomAmp.value),
            parseInt(grassThicknessInput.value),
            parseInt(dirtLayerDepthInput.value),
            parseInt(caveDensityInput.value),
            parseInt(caveSizeInput.value),
            parseFloat(caveVerticalBiasInput.value).toFixed(2),
            parseFloat(caveVerticalFreqInput.value).toFixed(3),
            parseFloat(waterLevelInput.value).toFixed(2)
        ];

        // Join them into a consistent string
        const settingsString = settings.join(',');
        
        // Hash the string to get a numerical seed
        // We'll use a constant seed for the hashing itself to ensure consistency
        const generatedSeed = cyrb53(settingsString, 1337) % 1000000000; // Keep seed manageable
        
        seedInput.value = generatedSeed;
        seedDisplay.textContent = generatedSeed;
        generateMap(); // Generate the map with this new seed
    }

    // Function to apply settings based on a given seed
    function applySettingsFromSeed() {
        const seed = parseInt(seedInput.value) || 12345;
        seedDisplay.textContent = seed;

        // Use a *new* LCG instance with this seed to generate reproducible random values for settings
        // This is crucial: the order and ranges of rng.next() calls must EXACTLY match
        // how you would deterministically generate settings from a seed.
        const rngForSettings = new LCG(seed);

        // Apply settings in a deterministic order, matching their ranges
        // Note: For some ranges, you might need to adjust the next() output
        // e.g., for baseHeightFactor (0.1 to 0.9), rng.next() * 0.8 + 0.1
        // Make sure min/max/step values from HTML inputs are respected for generation.

        widthInput.value = Math.floor(rngForSettings.next() * (1920 - 512 + 1)) + 512; // Example range
        heightInput.value = Math.floor(rngForSettings.next() * (1920 - 512 + 1)) + 512; // Example range
        baseHeightFactor.value = (rngForSettings.next() * (0.9 - 0.1) + 0.1).toFixed(2);
        smoothPassesInput.value = Math.floor(rngForSettings.next() * (20 - 0 + 1)) + 0;
        sin1Amp.value = Math.floor(rngForSettings.next() * (100 - 0 + 1)) + 0;
        sin1Freq.value = (rngForSettings.next() * (0.1 - 0) + 0).toFixed(3);
        sin2Amp.value = Math.floor(rngForSettings.next() * (50 - 0 + 1)) + 0;
        sin2Freq.value = (rngForSettings.next() * (0.1 - 0) + 0).toFixed(3);
        sin3Amp.value = Math.floor(rngForSettings.next() * (25 - 0 + 1)) + 0;
        sin3Freq.value = (rngForSettings.next() * (0.2 - 0) + 0).toFixed(3);
        sin4Amp.value = Math.floor(rngForSettings.next() * (10 - 0 + 1)) + 0;
        sin4Freq.value = (rngForSettings.next() * (0.5 - 0) + 0).toFixed(3);
        randomAmp.value = Math.floor(rngForSettings.next() * (20 - 0 + 1)) + 0;
        grassThicknessInput.value = Math.floor(rngForSettings.next() * (10 - 1 + 1)) + 1;
        dirtLayerDepthInput.value = Math.floor(rngForSettings.next() * (100 - 10 + 1)) + 10;
        caveDensityInput.value = Math.floor(rngForSettings.next() * (100 - 1 + 1)) + 1;
        caveSizeInput.value = Math.floor(rngForSettings.next() * (200 - 10 + 1)) + 10;
        caveVerticalBiasInput.value = (rngForSettings.next() * (1 - 0) + 0).toFixed(2);
        caveVerticalFreqInput.value = (rngForSettings.next() * (0.1 - 0.001) + 0.001).toFixed(3);
        waterLevelInput.value = (rngForSettings.next() * (1 - 0) + 0).toFixed(2);
        
        // After applying all settings, then generate the map
        generateMap();
    }


    genBtn.addEventListener('click', generateMap);
    downloadBtn.addEventListener('click', downloadImage);
    randomSeedBtn.addEventListener('click', generateSeedFromSettings); // "Get Seed" now generates from settings
    loadSeedBtn.addEventListener('click', applySettingsFromSeed); // "Load from Seed" now applies settings from the seed

    // Initial map generation on page load
    generateMap();
</script>
</body>
</html>