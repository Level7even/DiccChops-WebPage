<!-- sections/SketchFab.html -->
<div class="sketchfab-container">
  <h2>Dicc's SketchFab</h2>
  <p>Interactive 3D Environment</p>
  
  <div class="canvas-container">
    <canvas id="sketchfab-canvas"></canvas>
  </div>
  
  <div class="controls">
    <button id="toggle-lights">Toggle Lights</button>
    <button id="reset-camera">Reset Camera</button>
    <button id="change-sphere-color">Change Sphere Color</button>
  </div>
</div>

<style>
.sketchfab-container {
  padding: 20px;
  text-align: center;
  color: white;
}

.canvas-container {
  width: 100%;
  height: 500px;
  margin: 20px 0;
  border: 2px solid rgba(255, 255, 255, 0.1);
  border-radius: 8px;
  overflow: hidden;
}

#sketchfab-canvas {
  width: 100%;
  height: 100%;
  display: block;
}

.controls {
  margin-top: 20px;
}

.controls button {
  background: rgba(0, 170, 255, 0.3);
  border: 1px solid rgba(0, 170, 255, 0.5);
  color: white;
  padding: 10px 15px;
  margin: 0 10px;
  border-radius: 4px;
  cursor: pointer;
  transition: all 0.3s ease;
}

.controls button:hover {
  background: rgba(0, 170, 255, 0.5);
  transform: translateY(-2px);
}

h2 {
  color: #00aaff;
  margin-bottom: 10px;
}

p {
  opacity: 0.8;
  margin-bottom: 20px;
}
</style>

<script type="module">
// Import Three.js
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.180.0/build/three.module.js';

// Wait for DOM to be ready
document.addEventListener('DOMContentLoaded', function() {
  initSketchFab();
});

function initSketchFab() {
  console.log('Initializing SketchFab 3D scene...');
  
  // Scene setup
  const canvas = document.getElementById('sketchfab-canvas');
  if (!canvas) {
    console.error('Canvas element not found!');
    return;
  }
  
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x222222);
  
  // Camera setup
  const camera = new THREE.PerspectiveCamera(75, canvas.clientWidth / canvas.clientHeight, 0.1, 1000);
  camera.position.set(0, 5, 10);
  camera.lookAt(0, 0, 0);
  
  // Renderer setup
  const renderer = new THREE.WebGLRenderer({ 
    canvas: canvas, 
    antialias: true,
    alpha: true 
  });
  renderer.setSize(canvas.clientWidth, canvas.clientHeight);
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  
  console.log('Renderer created, setting up scene...');
  
  // Create a room (a large box with inverted normals)
  const roomGeometry = new THREE.BoxGeometry(20, 10, 20);
  const roomMaterial = new THREE.MeshStandardMaterial({ 
    color: 0x444444, 
    side: THREE.BackSide, // This makes the inside visible
    roughness: 0.7,
    metalness: 0.3
  });
  const room = new THREE.Mesh(roomGeometry, roomMaterial);
  room.receiveShadow = true;
  scene.add(room);
  console.log('Room created');
  
  // Add a floor with a different material
  const floorGeometry = new THREE.PlaneGeometry(20, 20);
  const floorMaterial = new THREE.MeshStandardMaterial({ 
    color: 0x333333, 
    roughness: 0.8,
    metalness: 0.2
  });
  const floor = new THREE.Mesh(floorGeometry, floorMaterial);
  floor.rotation.x = -Math.PI / 2;
  floor.position.y = -5;
  floor.receiveShadow = true;
  scene.add(floor);
  console.log('Floor created');
  
  // Add a test sphere in the center
  const sphereGeometry = new THREE.SphereGeometry(1, 32, 32);
  const sphereMaterial = new THREE.MeshStandardMaterial({ 
    color: 0x00aaff,
    roughness: 0.2,
    metalness: 0.8
  });
  const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
  sphere.castShadow = true;
  sphere.receiveShadow = true;
  scene.add(sphere);
  console.log('Sphere created at center');
  
  // Add lighting
  const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
  scene.add(ambientLight);
  
  const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
  directionalLight.position.set(5, 10, 7);
  directionalLight.castShadow = true;
  directionalLight.shadow.mapSize.width = 2048;
  directionalLight.shadow.mapSize.height = 2048;
  directionalLight.shadow.camera.near = 0.5;
  directionalLight.shadow.camera.far = 50;
  scene.add(directionalLight);
  
  // Add a point light for additional illumination
  const pointLight = new THREE.PointLight(0x00aaff, 0.5, 10);
  pointLight.position.set(-3, 3, -3);
  pointLight.castShadow = true;
  scene.add(pointLight);
  
  console.log('Lights added to scene');
  
  // Add grid helper for reference
  const gridHelper = new THREE.GridHelper(20, 20, 0x444444, 0x222222);
  gridHelper.position.y = -5;
  scene.add(gridHelper);
  
  // Add axes helper for reference
  const axesHelper = new THREE.AxesHelper(5);
  scene.add(axesHelper);
  
  // Mouse controls
  let isMouseDown = false;
  let previousMousePosition = {
    x: 0,
    y: 0
  };
  
  canvas.addEventListener('mousedown', function(e) {
    isMouseDown = true;
    previousMousePosition = {
      x: e.clientX,
      y: e.clientY
    };
  });
  
  canvas.addEventListener('mouseup', function() {
    isMouseDown = false;
  });
  
  canvas.addEventListener('mousemove', function(e) {
    if (!isMouseDown) return;
    
    const deltaMove = {
      x: e.clientX - previousMousePosition.x,
      y: e.clientY - previousMousePosition.y
    };
    
    // Rotate camera around the center
    const theta = Math.atan2(camera.position.x, camera.position.z);
    const phi = Math.atan2(Math.sqrt(camera.position.x*camera.position.x + camera.position.z*camera.position.z), camera.position.y);
    
    const radius = Math.sqrt(
      camera.position.x * camera.position.x +
      camera.position.y * camera.position.y +
      camera.position.z * camera.position.z
    );
    
    let newTheta = theta - deltaMove.x * 0.01;
    let newPhi = phi - deltaMove.y * 0.01;
    
    // Prevent flipping
    newPhi = Math.max(0.1, Math.min(Math.PI - 0.1, newPhi));
    
    camera.position.x = radius * Math.sin(newPhi) * Math.sin(newTheta);
    camera.position.y = radius * Math.cos(newPhi);
    camera.position.z = radius * Math.sin(newPhi) * Math.cos(newTheta);
    
    camera.lookAt(0, 0, 0);
    
    previousMousePosition = {
      x: e.clientX,
      y: e.clientY
    };
  });
  
  // Add wheel event for zooming
  canvas.addEventListener('wheel', function(e) {
    e.preventDefault();
    
    // Zoom in/out based on wheel direction
    const zoomFactor = 0.1;
    const direction = e.deltaY > 0 ? 1 : -1;
    
    // Move camera along the direction it's facing
    const vector = new THREE.Vector3();
    camera.getWorldDirection(vector);
    camera.position.addScaledVector(vector, direction * zoomFactor);
  });
  
  // Control buttons functionality
  document.getElementById('toggle-lights').addEventListener('click', function() {
    directionalLight.visible = !directionalLight.visible;
    pointLight.visible = !pointLight.visible;
  });
  
  document.getElementById('reset-camera').addEventListener('click', function() {
    camera.position.set(0, 5, 10);
    camera.lookAt(0, 0, 0);
  });
  
  document.getElementById('change-sphere-color').addEventListener('click', function() {
    // Generate a random color
    const randomColor = new THREE.Color(
      Math.random(),
      Math.random(),
      Math.random()
    );
    sphereMaterial.color = randomColor;
  });
  
  // Animation loop
  function animate() {
    requestAnimationFrame(animate);
    
    // Rotate the sphere slowly
    sphere.rotation.y += 0.01;
    
    // Render the scene
    renderer.render(scene, camera);
  }
  
  // Handle window resize
  window.addEventListener('resize', function() {
    camera.aspect = canvas.clientWidth / canvas.clientHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(canvas.clientWidth, canvas.clientHeight);
  });
  
  // Initial render
  renderer.render(scene, camera);
  console.log('Starting animation loop...');
  
  // Start animation
  animate();
}
</script>